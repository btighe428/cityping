generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================================================
// ACCOUNTS & AUTHENTICATION
// ============================================================================

model Account {
  id               String   @id @default(uuid()) @db.Uuid
  stripeCustomerId String   @unique @map("stripe_customer_id")
  email            String?
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz

  phones        Phone[]
  subscriptions Subscription[]

  @@map("accounts")
}

model Phone {
  id             String         @id @default(uuid()) @db.Uuid
  accountId      String         @map("account_id") @db.Uuid
  e164           String         @unique
  smsOptInStatus SmsOptInStatus @default(pending) @map("sms_opt_in_status")
  smsOptInAt     DateTime?      @map("sms_opt_in_at") @db.Timestamptz
  smsOptInSource String?        @map("sms_opt_in_source")
  smsOptInIp     String?        @map("sms_opt_in_ip") @db.Inet
  createdAt      DateTime       @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime       @updatedAt @map("updated_at") @db.Timestamptz

  account      Account          @relation(fields: [accountId], references: [id], onDelete: Cascade)
  cityAlerts   PhoneCityAlert[]
  messages     MessageOutbox[]
  manageTokens ManageToken[]

  @@map("phones")
}

enum SmsOptInStatus {
  pending
  confirmed
  revoked

  @@map("sms_opt_in_status")
}

model Subscription {
  id                   String    @id @default(uuid()) @db.Uuid
  accountId            String    @map("account_id") @db.Uuid
  stripeSubscriptionId String    @unique @map("stripe_subscription_id")
  status               String // active, trialing, past_due, canceled, unpaid, etc.
  currentPeriodEnd     DateTime? @map("current_period_end") @db.Timestamptz
  cancelAtPeriodEnd    Boolean   @default(false) @map("cancel_at_period_end")
  priceId              String    @map("price_id")
  createdAt            DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt            DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

// ============================================================================
// CITIES & ALERTS
// ============================================================================

model City {
  id                   String   @id @default(uuid()) @db.Uuid
  slug                 String   @unique
  name                 String
  timezone             String // e.g., "America/New_York"
  defaultSendTimeLocal String   @default("18:00") @map("default_send_time_local")
  createdAt            DateTime @default(now()) @map("created_at") @db.Timestamptz

  phoneAlerts      PhoneCityAlert[]
  calendarSources  CalendarSource[]
  suspensionEvents SuspensionEvent[]
  messages         MessageOutbox[]

  @@map("cities")
}

model PhoneCityAlert {
  phoneId                String   @map("phone_id") @db.Uuid
  cityId                 String   @map("city_id") @db.Uuid
  enabled                Boolean  @default(true)
  notifySms              Boolean  @default(true) @map("notify_sms")
  notifyEmail            Boolean  @default(true) @map("notify_email")
  preferredSendTimeLocal String?  @map("preferred_send_time_local")
  createdAt              DateTime @default(now()) @map("created_at") @db.Timestamptz

  phone Phone @relation(fields: [phoneId], references: [id], onDelete: Cascade)
  city  City  @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@id([phoneId, cityId])
  @@map("phone_city_alerts")
}

// ============================================================================
// CALENDAR & EVENTS
// ============================================================================

model CalendarSource {
  id            String    @id @default(uuid()) @db.Uuid
  cityId        String    @map("city_id") @db.Uuid
  sourceType    String    @default("ics") @map("source_type") // "ics"
  discoverUrl   String?   @map("discover_url")
  sourceUrl     String    @map("source_url")
  year          Int?
  etag          String?
  lastModified  String?   @map("last_modified")
  lastFetchedAt DateTime? @map("last_fetched_at") @db.Timestamptz
  lastParsedAt  DateTime? @map("last_parsed_at") @db.Timestamptz
  rawHash       String?   @map("raw_hash")
  isActive      Boolean   @default(true) @map("is_active")
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz

  city   City              @relation(fields: [cityId], references: [id], onDelete: Cascade)
  events SuspensionEvent[]

  @@map("calendar_sources")
}

model SuspensionEvent {
  id         String   @id @default(uuid()) @db.Uuid
  cityId     String   @map("city_id") @db.Uuid
  sourceId   String   @map("source_id") @db.Uuid
  eventUid   String?  @map("event_uid")
  summary    String? // Holiday name/reason
  date       DateTime @db.Date // One row per suspension day
  rawStart   String?  @map("raw_start")
  rawEnd     String?  @map("raw_end")
  lastSeenAt DateTime @default(now()) @map("last_seen_at") @db.Timestamptz

  city   City           @relation(fields: [cityId], references: [id], onDelete: Cascade)
  source CalendarSource @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@unique([cityId, date, summary])
  @@map("suspension_events")
}

// ============================================================================
// MESSAGING
// ============================================================================

model MessageOutbox {
  id               String        @id @default(uuid()) @db.Uuid
  phoneId          String        @map("phone_id") @db.Uuid
  cityId           String?       @map("city_id") @db.Uuid
  type             MessageType
  targetDate       DateTime?     @map("target_date") @db.Date // For reminders
  body             String
  twilioMessageSid String?       @map("twilio_message_sid")
  status           MessageStatus @default(queued)
  errorCode        String?       @map("error_code")
  createdAt        DateTime      @default(now()) @map("created_at") @db.Timestamptz
  updatedAt        DateTime      @updatedAt @map("updated_at") @db.Timestamptz

  phone Phone @relation(fields: [phoneId], references: [id], onDelete: Cascade)
  city  City? @relation(fields: [cityId], references: [id], onDelete: SetNull)

  @@unique([phoneId, cityId, type, targetDate])
  @@map("message_outbox")
}

enum MessageType {
  opt_in
  reminder
  help
  system
  monthly_recap

  @@map("message_type")
}

enum MessageStatus {
  queued
  sent
  delivered
  failed

  @@map("message_status")
}

// ============================================================================
// WEBHOOKS & TOKENS
// ============================================================================

model WebhookEvent {
  id          String    @id @default(uuid()) @db.Uuid
  provider    String // "stripe" or "twilio"
  eventId     String    @map("event_id")
  payload     Json
  receivedAt  DateTime  @default(now()) @map("received_at") @db.Timestamptz
  processedAt DateTime? @map("processed_at") @db.Timestamptz

  @@unique([provider, eventId])
  @@map("webhook_events")
}

model ManageToken {
  id        String    @id @default(uuid()) @db.Uuid
  phoneId   String    @map("phone_id") @db.Uuid
  tokenHash String    @unique @map("token_hash")
  expiresAt DateTime  @map("expires_at") @db.Timestamptz
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz
  usedAt    DateTime? @map("used_at") @db.Timestamptz

  phone Phone @relation(fields: [phoneId], references: [id], onDelete: Cascade)

  @@map("manage_tokens")
}

// ============================================================================
// USERS (Unified Model - coexists with legacy Phone/Account during migration)
// ============================================================================

/// User tier classification determining notification channels and timing.
/// Free: Email digest with 24-hour delay
/// Premium: SMS + Email with instant delivery
enum UserTier {
  free
  premium

  @@map("user_tier")
}

/// Personality preset controlling AI-generated notification tone and verbosity.
/// TRANSPLANT: Enthusiastic newcomer, explains everything with helpful context
/// REGULAR: Balanced, practical (default) - clear and efficient
/// LOCAL: Brief, insider knowledge, assumes familiarity with NYC
enum VibePreset {
  TRANSPLANT
  REGULAR
  LOCAL

  @@map("vibe_preset")
}

/// Unified user model for NYCPing multi-module architecture.
/// Consolidates identity, subscription tier, and inferred location profile.
/// Coexists with legacy Phone/Account models during migration period.
model User {
  id               String   @id @default(cuid())
  phone            String?  @unique // E.164 format, optional for free tier
  email            String   @unique
  zipCode          String   @map("zip_code")
  tier             UserTier @default(free)
  stripeCustomerId String?  @unique @map("stripe_customer_id")

  // Inferred profile (populated by zip-to-geo service)
  inferredNeighborhood String?  @map("inferred_neighborhood")
  inferredSubwayLines  String[] @map("inferred_subway_lines")
  inferredHasParking   Boolean  @default(false) @map("inferred_has_parking")

  // User preference (selected at signup)
  preferredBorough String?    @map("preferred_borough") // manhattan, brooklyn, queens, bronx, staten_island
  vibePreset       VibePreset @default(REGULAR) @map("vibe_preset")

  // Opt-in tracking
  smsOptInStatus SmsOptInStatus @default(pending) @map("sms_opt_in_status")
  smsOptInAt     DateTime?      @map("sms_opt_in_at") @db.Timestamptz
  emailOptInAt   DateTime       @default(now()) @map("email_opt_in_at") @db.Timestamptz

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  preferences       UserModulePreference[]
  notifications     NotificationOutbox[]
  feedback          UserEventFeedback[]
  referralsSent     Referral[]             @relation("ReferralsSent")
  referralsReceived Referral[]             @relation("ReferralsReceived")

  @@map("users")
}

// ============================================================================
// NYCPING MULTI-MODULE ARCHITECTURE
// ============================================================================

/// Represents a top-level feature module in NYCPing (parking, transit, events, etc.)
/// Each module groups related alert sources and user preferences.
model Module {
  id          String @id // "parking", "transit", "events", "housing", "food", "deals"
  name        String // "Parking & Driving"
  description String
  icon        String // Emoji identifier
  sortOrder   Int    @map("sort_order")

  sources          AlertSource[]
  preferences      UserModulePreference[]
  inferenceWeights ZipCodeInferenceWeight[]

  @@map("modules")
}

/// Junction table linking users to modules with per-module preferences.
/// Supports both explicit opt-in/out and inferred preferences based on user profile.
/// Settings JSON allows module-specific configuration (e.g., transit line filters).
model UserModulePreference {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  moduleId   String   @map("module_id")
  enabled    Boolean  @default(true)
  settings   Json     @default("{}")
  isInferred Boolean  @default(true) @map("is_inferred")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt  DateTime @updatedAt @map("updated_at") @db.Timestamptz

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  module Module @relation(fields: [moduleId], references: [id])

  @@unique([userId, moduleId])
  @@map("user_module_preferences")
}

/// An individual data source within a module that generates alerts.
/// Examples: ASP calendar, MTA subway status, 311 street closures.
model AlertSource {
  id           String          @id @default(cuid())
  moduleId     String          @map("module_id")
  slug         String          @unique // "asp-calendar", "mta-subway"
  name         String // "Alternate Side Parking"
  frequency    SourceFrequency
  enabled      Boolean         @default(true)
  config       Json            @default("{}")
  lastPolledAt DateTime?       @map("last_polled_at") @db.Timestamptz
  lastEventAt  DateTime?       @map("last_event_at") @db.Timestamptz

  module Module       @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  events AlertEvent[]

  @@map("alert_sources")
}

/// Individual alert events ingested from various sources.
/// Each event represents a single notification-worthy occurrence (e.g., ASP suspension, subway delay).
model AlertEvent {
  id            String    @id @default(cuid())
  sourceId      String    @map("source_id")
  externalId    String?   @map("external_id") // Dedup key from source
  title         String
  body          String?
  startsAt      DateTime? @map("starts_at") @db.Timestamptz
  endsAt        DateTime? @map("ends_at") @db.Timestamptz
  neighborhoods String[] // For geo-matching
  metadata      Json      @default("{}")
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz
  expiresAt     DateTime? @map("expires_at") @db.Timestamptz

  // Hype scoring for sample sales and high-demand events
  hypeScore   Int?  @map("hype_score") // 0-100 composite score
  hypeFactors Json? @map("hype_factors") // { brandTier: 80, scarcity: +15, aiAdj: +5 }

  source        AlertSource          @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  notifications NotificationOutbox[]
  feedback      UserEventFeedback[]

  @@unique([sourceId, externalId])
  @@index([sourceId, createdAt])
  @@index([startsAt])
  @@map("alert_events")
}

/// Polling frequency classification for alert sources.
/// Determines how often the system checks for new data.
enum SourceFrequency {
  realtime // Poll every 60-90 sec (e.g., subway delays)
  hourly // Cron hourly (e.g., weather updates)
  daily // Cron daily (e.g., ASP calendar sync)

  @@map("source_frequency")
}

// ============================================================================
// REFERRAL PROGRAM
// ============================================================================

/// Referral status tracking for viral growth incentives.
/// PENDING: Referred user signed up but not yet converted to paid subscription
/// CONVERTED: Referred user completed paid subscription (reward earned)
/// EXPIRED: Referral expired without conversion (typically 30-90 day window)
enum ReferralStatus {
  PENDING // Referred user signed up but not converted
  CONVERTED // Referred user completed paid subscription
  EXPIRED // Referral expired without conversion

  @@map("referral_status")
}

/// Referral tracking model for viral growth program.
/// Links a referrer (existing user) to a referee (new user) with status tracking.
/// Supports both pre-signup referrals (by email) and post-signup conversions.
/// Integrates with Stripe for coupon-based reward fulfillment.
model Referral {
  id             String         @id @default(cuid())
  referrerId     String         @map("referrer_id")
  refereeId      String?        @map("referee_id")
  refereeEmail   String         @map("referee_email")
  referralCode   String         @unique @map("referral_code")
  status         ReferralStatus @default(PENDING)
  stripeCouponId String?        @map("stripe_coupon_id")
  convertedAt    DateTime?      @map("converted_at") @db.Timestamptz
  expiresAt      DateTime       @map("expires_at") @db.Timestamptz
  createdAt      DateTime       @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime       @updatedAt @map("updated_at") @db.Timestamptz

  referrer User  @relation("ReferralsSent", fields: [referrerId], references: [id], onDelete: Cascade)
  referee  User? @relation("ReferralsReceived", fields: [refereeId], references: [id], onDelete: SetNull)

  @@index([referralCode])
  @@index([refereeEmail])
  @@index([referrerId])
  @@map("referrals")
}

// ============================================================================
// FEEDBACK LOOP - User Event Feedback
// ============================================================================

/// Feedback type for user event ratings.
/// Simple binary classification for aggregation and scoring adjustments.
enum FeedbackType {
  THUMBS_UP
  THUMBS_DOWN

  @@map("feedback_type")
}

/// User feedback on alert events for relevance scoring.
/// Enables feedback loop: users rate events, system learns preferences by zip code.
/// Token-based verification for email link clicks (no login required).
model UserEventFeedback {
  id             String       @id @default(uuid()) @db.Uuid
  userId         String       @map("user_id")
  eventId        String       @map("event_id")
  feedbackType   FeedbackType @map("feedback_type")
  feedbackToken  String       @unique @map("feedback_token")
  tokenExpiresAt DateTime     @map("token_expires_at") @db.Timestamptz
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamptz

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  event AlertEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([feedbackToken])
  @@map("user_event_feedback")
}

/// Aggregated inference weights per zip code and module.
/// Stores positive/negative feedback counts and computed adjustment factor.
/// Used to boost/suppress event relevance for specific neighborhoods.
model ZipCodeInferenceWeight {
  id               String   @id @default(uuid()) @db.Uuid
  zipCode          String   @map("zip_code")
  moduleId         String   @map("module_id")
  positiveCount    Int      @default(0) @map("positive_count")
  negativeCount    Int      @default(0) @map("negative_count")
  adjustmentFactor Float    @default(1.0) @map("adjustment_factor")
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz

  module Module @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  @@unique([zipCode, moduleId])
  @@index([zipCode])
  @@map("zip_code_inference_weights")
}

// ============================================================================
// NOTIFICATION OUTBOX (Transactional Outbox Pattern)
// ============================================================================

/// Delivery channel for notifications.
/// SMS available for premium tier; email for all users.
enum NotificationChannel {
  sms
  email

  @@map("notification_channel")
}

/// Lifecycle status of a notification in the outbox.
/// pending: Awaiting send at scheduledFor time
/// sent: Successfully delivered to provider
/// failed: Delivery failed (retries exhausted or permanent error)
/// skipped: User preference changed or event expired before send
enum NotificationStatus {
  pending
  sent
  failed
  skipped

  @@map("notification_status")
}

/// Transactional outbox for reliable notification delivery.
/// Implements exactly-once semantics via unique constraint on (user, event, channel).
/// Scheduler polls for pending notifications where scheduledFor <= now().
/// Supports tier-based timing: premium gets instant, free gets 24h delay.
model NotificationOutbox {
  id           String              @id @default(cuid())
  userId       String              @map("user_id")
  eventId      String              @map("event_id")
  channel      NotificationChannel
  scheduledFor DateTime            @map("scheduled_for") @db.Timestamptz
  sentAt       DateTime?           @map("sent_at") @db.Timestamptz
  status       NotificationStatus  @default(pending)
  createdAt    DateTime            @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime            @updatedAt @map("updated_at") @db.Timestamptz

  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  event AlertEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId, channel])
  @@index([status, scheduledFor])
  @@map("notification_outbox")
}

// ============================================================================
// CITY PULSE - NYC Events Intelligence
// ============================================================================

/// Category classification for city events
enum EventCategory {
  culture // Museums, galleries, theater, music
  sports // Games, playoffs, marathons
  food // Restaurant openings, deals, food events
  civic // Housing lotteries, signups, voting
  weather // Forecasts, snow days, heat waves
  transit // Service changes, new routes
  seasonal // Holidays, tree lightings, parades
  local // Neighborhood-specific, community

  @@map("event_category")
}

/// Curation status for city events
enum CurationStatus {
  auto // Auto-published (factual content)
  review // Awaiting human review
  published // Approved and visible
  rejected // Not suitable for publication

  @@map("curation_status")
}

/// City events from all NYC sources - the canonical calendar
/// Powers the daily/weekly digest emails with insider intelligence
model CityEvent {
  id String @id @default(cuid())

  // What
  title          String
  description    String? // AI-generated insider copy
  rawDescription String? @map("raw_description") // Original source text

  // When
  startsAt    DateTime? @map("starts_at") @db.Timestamptz
  endsAt      DateTime? @map("ends_at") @db.Timestamptz
  deadlineAt  DateTime? @map("deadline_at") @db.Timestamptz // Signup deadline
  announcedAt DateTime? @map("announced_at") @db.Timestamptz

  // Where
  venue        String?
  neighborhood String?
  borough      String?
  latitude     Float?
  longitude    Float?

  // Classification
  category    EventCategory
  subcategory String?
  tags        String[]      @default([])

  // Intelligence scores (0-100)
  insiderScore  Int @default(0) @map("insider_score")
  scarcityScore Int @default(0) @map("scarcity_score")
  timingScore   Int @default(0) @map("timing_score")
  cachetScore   Int @default(0) @map("cachet_score")

  // Curation
  status       CurationStatus @default(review)
  aiConfidence Float          @default(0) @map("ai_confidence") // 0-1
  editorNotes  String?        @map("editor_notes")

  // Source tracking
  sourceType String? @map("source_type") // "api", "rss", "scrape", "manual"
  sourceName String? @map("source_name") // "TimeOut", "NYC.gov", etc.
  externalId String? @map("external_id")
  sourceUrl  String? @map("source_url")

  // Evergreen linkage
  isRecurring    Boolean @default(false) @map("is_recurring")
  recurrenceRule String? @map("recurrence_rule") // "first Sunday November"
  evergreenId    String? @map("evergreen_id")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  evergreen EvergreenEvent? @relation(fields: [evergreenId], references: [id])

  @@unique([sourceName, externalId])
  @@index([startsAt])
  @@index([category])
  @@index([status])
  @@index([insiderScore])
  @@map("city_events")
}

/// Pre-seeded annual NYC events that recur each year
/// AI monitors for official date announcements and creates CityEvent instances
model EvergreenEvent {
  id String @id @default(cuid())

  name        String // "Rockefeller Tree Lighting"
  typicalDate String        @map("typical_date") // "last Wednesday of November"
  typicalTime String?       @map("typical_time") // "7pm"
  category    EventCategory

  // Insider knowledge
  insiderContext String?  @map("insider_context") @db.Text // Local wisdom
  tips           String[] @default([]) // Array of pro tips

  // Notification timing
  anticipationDays Int[] @default([30, 7, 1]) @map("anticipation_days")

  // Monitoring
  sources       String[]  @default([]) // URLs to watch for announcements
  lastCheckedAt DateTime? @map("last_checked_at") @db.Timestamptz

  // Metadata
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  instances CityEvent[]

  @@map("evergreen_events")
}
